(in-package #:escenario)

(defparameter *sprites* '((1.5 22.5 9)
                          (1.5 1.5 10)
                          (1.5 2.5 10)
                          (2.5 1.5 10)
                          (3.5 1.5 10)
                          (6.5 7.5 9)
                          (4.5 1.5 10)
                          (1.5 5.0 10)
                          (1.5 5.75 9)
                          (1.5 6.50 9)
                          (1.5 7.25 10)
                          (1.5 10.0 10)
                          (1.5 9.50 9)
                          (1.5 11.0 10)
                          (1.5 11.75 10)
                          (1.5 12.5 9)
                          (6.5 10.5 9)))

(defparameter *sprites-fronteras* nil)
;;(defparameter *sprites-fronteras* '((8 . #(34 62 95 123)) (9 . #(45 0 85 15))))

;;(defparameter *sprites-eventos* nil)
(defparameter *sprites-eventos* '((10 . ((:contacto . (:sonido . 2))))
                                  (9 . ((:contacto . (:sonido . 2))))))

;;(defparameter *sprites-eventos* nil)

(defclass sprite ()
  ((x :initform 0.0 :type single-float :accessor sprite-x :initarg :x)
   (y :initform 0.0 :type single-float :accessor sprite-y :initarg :y)
   (frontera :initform  #(0 0 127 127):type (simple-vector 4) :accessor sprite-frontera :initarg :frontera)
   (posición :initform (vec2 0.0 0.0) :accessor sprite-posición :initarg :posición)
   (textura :initform 0 :type fixnum :accessor sprite-textura :initarg :textura)
   (eventos :initform nil :accessor sprite-eventos :initarg :eventos)))

(defun carga-sprites (sprites fronteras eventos)
  (make-array (length sprites)
              :element-type 'sprite
              :initial-contents
              (mapcar (lambda (s)
                        (let ((obj (make-instance 'sprite
                                                  :x (car s) :y (cadr s)
                                                  :posición (vec2 (car s) (cadr s))
                                                  :textura (caddr s))))
                          (when fronteras
                            (let ((def (cdr (assoc (caddr s) fronteras))))
                              (setf (sprite-frontera obj)
                                    (if def def `#(0 0 ,(1- *tex-ancho-fix*)
                                                   ,(1- *tex-alto-fix*))))))
                          (when eventos
                            (let ((evs (cdr (assoc (caddr s) eventos))))
                              (when evs
                                (setf (sprite-eventos obj)
                                      (mapcar (lambda (ev)
                                                (make-instance
                                                 (intern (concatenate 'string "EVENTO-"
                                                                      (symbol-name (car ev)))
                                                         'escenario)
                                                 :accion (make-instance
                                                          (intern (concatenate 'string
                                                                               "ACCION-"
                                                                               (symbol-name (cadr ev)))
                                                                  'escenario)
                                                          :pars (cddr ev))))
                                              evs)))))
                          obj))
                      sprites)))

(declaim (inline sprites-ordena))
(defun sprites-ordena (posición sprites)
  (declare (optimize (speed 3) (safety 0) (debug 0))
           (type (simple-array sprite) sprites))
  (sort sprites #'> :key (lambda (s)
                           (declare (optimize (speed 3) (safety 0) (debug 0)))
                           (let ((x (- (vx2 posición) (the single-float (sprite-x s))))
                                 (y (- (vy2 posición) (the single-float (sprite-y s)))))
                             (declare (type single-float x y))
                             (+ (* x x) (* y y))))))

(defun sprites-dibuja (pixels x-inicial ancho-franja ancho alto pos-x pos-y
                       plcam-x plcam-y dir-x dir-y sprites zbuffer texturas)
  (declare (optimize (speed 3) (safety 0) (debug 0))
           (type (simple-array (unsigned-byte 32) *) pixels)
           (type (simple-array sprite) sprites)
           (type (simple-array single-float) zbuffer)
           (type (simple-array (simple-array (unsigned-byte 32))) texturas)
           (type single-float x-inicial ancho-franja ancho alto
                 pos-x pos-y plcam-x plcam-y dir-x dir-y))
  (let ((inv-det (/ (- (* plcam-x dir-y) (* dir-x plcam-y))))
        (alto/2 (/ alto 2.0)))
    (declare (type single-float inv-det alto/2))
    (labels ((dibuja (s trans-x trans-y)
               (let* ((frontera (sprite-frontera s))
                      (sprite-screen-x (* (/ ancho 2.0) (1+ (divseg trans-x trans-y))))
                      (sprite-ancho (abs (divseg alto trans-y)))
                      (sprite-ancho/2 (/ sprite-ancho 2.0))
                      (y-ini (- alto/2 sprite-ancho/2))
                      (y-fin (+ alto/2 sprite-ancho/2))
                      (prop-ancho (divseg *tex-ancho* sprite-ancho)))
                 (declare (type single-float sprite-screen-x sprite-ancho
                                sprite-ancho/2 y-ini y-fin prop-ancho)
                          (type (simple-array fixnum (4)) frontera))
                 (loop with tex-x fixnum = 0
                    for x single-float from x-inicial below (+ x-inicial ancho-franja)
                    for x-fix fixnum = (truncate x)
                    if (< trans-y (aref zbuffer x-fix))
                    do (setf tex-x  (truncate (* (- (+ x sprite-ancho/2) sprite-screen-x)
                                                 prop-ancho)))
                      (when (and (>= tex-x (the fixnum (aref frontera 0)))
                                 (<= tex-x (the fixnum (aref frontera 2))))
                        (loop for y single-float from (if (minusp y-ini) 0.0 y-ini) below (if (>= y-fin alto) (1- alto) y-fin)
                           for tex-y fixnum = (truncate (divseg (* (- y y-ini) *tex-alto-fix*) sprite-ancho))
                           for color = (aref (aref texturas (sprite-textura s)) tex-y tex-x)
                           if (and (>= tex-y (the fixnum (aref frontera 1)))
                                   (<= tex-y (the fixnum (aref frontera 3)))
                                   (/= 0 color))
                           do (let ((y-fix (truncate y)))
                                (declare (type fixnum y-fix))
                                (setf (aref pixels y-fix x-fix)
                                      (case color
                                        (#xFFE8AB (let ((a (aref pixels y-fix x-fix)))
                                                    (ash (- (+ a color) (logand (logxor a color)
                                                                                #x010101))
                                                         -1)))
                                        (#xFFE8AC (logand (aref pixels y-fix x-fix) color))
                                        (t color))))))))))
      (declare (inline dibuja))
      (loop for s across sprites
         for s-x single-float = (- (the single-float (sprite-x s)) pos-x)
         and s-y single-float = (- (the single-float (sprite-y s)) pos-y)
         for trans-x single-float = (* inv-det (- (* dir-y s-x) (* dir-x s-y)))
         and trans-y single-float = (* inv-det (- (* plcam-x s-y) (* plcam-y s-x)))
         if (plusp trans-y) do (dibuja s trans-x trans-y)))))

;;(ash (+ (logand a #xfEfEfE) (logand color #xfEfEfE)) -1)
