(in-package #:escenario)

(defparameter *sprites* '((1.5 22.5 23)
                          (1.5 1.5 23)
                          (1.5 2.5 8)
                          (2.5 1.5 8)
                          (3.5 1.5 8)
                          (1.51 1.51 9)
                          (2.5 1.5 9)
                          (3.5 1.5 9)
                          (6.5 7.5 9)
                          (4.5 1.5 22)
                          (1.5 5.0 21)
                          (1.5 5.75 21)
                          (1.5 6.50 21)
                          (1.5 7.25 21)
                          (1.5 8.0 21)
                          (1.5 8.75 21)
                          (1.5 9.50 21)
                          (1.5 10.25 21)
                          (1.5 11.0 21)
                          (1.5 11.75 21)
                          (1.5 12.5 22)
                          (6.5 8.5 21)))

(defparameter *sprites-fronteras* '((8 . #(34 62 95 123))
                                    (9 . #(45 0 85 21))))

(defparameter *sprites-eventos* '((21 . ((:contacto . (:snd . 2))))
                                  (22 . ((:contacto . (:snd . 2))))))


(defclass sprite ()
  ((x :initform 0.0 :type single-float :accessor sprite-x :initarg :x)
   (y :initform 0.0 :type single-float :accessor sprite-y :initarg :y)
   (frontera :initform  #(0 0 123 123):type (simple-array fixnum) :accessor sprite-frontera :initarg :frontera)
   (posición :initform (vec2 0.0 0.0) :accessor sprite-posición :initarg :posición)
   (textura :initform 0 :type fixnum :accessor sprite-textura :initarg :textura)
   (eventos :initform nil :accessor sprite-eventos :initarg :eventos)))

(defun carga-sprites (sprites fronteras eventos)
  (make-array (length sprites)
              :element-type 'sprite
              :initial-contents (mapcar (lambda (s)
                                          (let ((obj (make-instance 'sprite
                                                                    :x (car s) :y (cadr s)
                                                                    :posición (vec2 (car s) (cadr s))
                                                                    :textura (caddr s))))
                                            (when fronteras
                                              (let ((def (cdr (assoc (caddr s) fronteras))))
                                                (setf (sprite-frontera obj)
                                                      (if def def `#(0 0 ,(1- *tex-ancho-fix*) ,(1- *tex-alto-fix*))))))
                                            (when eventos
                                              (let ((def (cdr (assoc (caddr s) eventos))))
                                                (when def
                                                  (setf (sprite-eventos obj) def))))
                                            obj))
                                        sprites)))


(declaim (inline sprites-ordena))
(defun sprites-ordena (posición sprites)
  (declare (optimize (speed 3) (safety 0) (debug 0))
           (type (simple-array sprite) sprites))
  (sort sprites #'> :key (lambda (s)
                           (declare (optimize (speed 3) (safety 0) (debug 0)))
                           (let ((x (- (vx2 posición) (the single-float (sprite-x s))))
                                 (y (- (vy2 posición) (the single-float (sprite-y s)))))
                             (declare (type single-float x y))
                             (+ (* x x) (* y y))))))

(defun sprites-dibuja (pixels x-inicial ancho-franja ancho alto pos-x pos-y plcam-x plcam-y dir-x dir-y sprites zbuffer texturas)
  (declare (optimize (speed 3) (safety 0) (debug 0))
           (type (simple-array (unsigned-byte 32) *) pixels)
           (type (simple-array sprite) sprites)
           (type (simple-array single-float) zbuffer)
           (type (simple-array (simple-array (unsigned-byte 32))) texturas)
           (type single-float x-inicial ancho-franja ancho alto pos-x pos-y plcam-x plcam-y dir-x dir-y))
  (loop with inv-det single-float = (/ (- (* plcam-x dir-y) (* dir-x plcam-y)))
     for s across sprites
     for s-x single-float = (- (the single-float (sprite-x s)) pos-x)
     and s-y single-float = (- (the single-float (sprite-y s)) pos-y)
     and frontera of-type (simple-array fixnum) = (sprite-frontera s)
     for trans-x single-float = (* inv-det (- (* dir-y s-x) (* dir-x s-y)))
     and trans-y single-float = (* inv-det (- (* plcam-x s-y) (* plcam-y s-x)))
     for sprite-screen-x fixnum = (the fixnum (truncate (* (/ ancho 2.0) (1+ (divseg trans-x trans-y)))))
     and sprite-alto single-float  = (abs (divseg alto trans-y))
     for sprite-ancho single-float = sprite-alto
     for y-ini single-float = (/ (- alto sprite-alto) 2)
     and y-fin single-float = (/ (+ alto sprite-alto) 2)
     and x-ini single-float = (- sprite-screen-x (/ sprite-ancho 2))
     and x-fin single-float = (+ sprite-screen-x (/ sprite-ancho 2))
     do (loop for x single-float from (if (< x-ini x-inicial) x-inicial x-ini) below (let ((x-max (+ x-inicial ancho-franja)))
                                                                                       (if (> x-fin x-max) x-max x-fin))
           for x-fix fixnum = (truncate x)
           for tex-x fixnum = (truncate (* (- x (+ (/ (- sprite-ancho) 2) sprite-screen-x))
                                           (divseg *tex-ancho* sprite-ancho)))
           if (and (>= tex-x (aref frontera 0)) (<= tex-x (aref frontera 2))
                   (plusp trans-y)
                   (< trans-y (aref zbuffer x-fix))
                   (plusp x) (< x ancho))
           do (loop for y single-float from (if (minusp y-ini) 0 y-ini) below (if (>= y-fin alto) (1- alto) y-fin)
                 for y-fix fixnum = (truncate y)
                 for d single-float = (+ y (/ (- sprite-alto alto) 2))
                 for tex-y fixnum = (truncate (divseg (* d *tex-alto-fix*) sprite-alto))
                 for color = (aref (aref texturas (sprite-textura s)) tex-y tex-x)
                 if (and (>= tex-y (aref frontera 1)) (<= tex-y (aref frontera 3))
                         (/= 0 color))
                 do (setf (aref pixels y-fix x-fix)
                          (case color
                            (#xFFE8AB
                             (let ((a (aref pixels y-fix x-fix)))
                               (ash (- (+ a color) (logand (logxor a color) #x010101)) -1)))
                            (#xFFE8AC (logand (aref pixels y-fix x-fix) color))
                            (t color)))))))
;;(ash (+ (logand a #xfEfEfE) (logand color #xfEfEfE)) -1)
